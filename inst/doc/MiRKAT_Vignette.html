<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Anna Plantinga, Nehemiah Wilson, Haotian Zheng, Xiang Zhan, Michael Wu, Jun Chen, Ni Zhao" />


<title>MiRKAT Package Vignette</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">MiRKAT Package Vignette</h1>
<h4 class="author">Anna Plantinga, Nehemiah Wilson, Haotian Zheng, Xiang Zhan, Michael Wu, Jun Chen, Ni Zhao</h4>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p>The MiRKAT package (v1.1.0) contains functions that test global associations between the microbiota and different types of phenotypes, such as univariate continuous or binary phenotypes, survival (censored time-to-event) outcomes, longitudinal data, multivariate, and structured phenotypes. For all these effects, the microbiome community effect is modeled nonparametrically through a kernel function, which can incorporate the phylogenetic tree information.</p>
<div id="changes-from-v1.0.1" class="section level3">
<h3>Changes from v1.0.1</h3>
<p>Four additional functions have beeen added to the package in version 1.1.0. They are MiRKAT.R (robust linear regression), MiRKAT.Q (quantile regression), GLMMMiRKAT (for correlated outcome data), and CSKAT (an alternative to GLMMMiRKAT for correlated Gaussian outcomes, utilizing the Davies approximation to calculate the p-value computationally). In addition, measures of effect size (the KRV statistic and R-squared) have been added to most functions.</p>
</div>
<div id="dependencies" class="section level3">
<h3>Dependencies</h3>
<p>The following packages are required for functions and examples in the MiRKAT package: MASS, GUniFrac, CompQuadForm, quantreg, PearsonDS, propr, lme4, Matrix, permute, survival, and stats. All of these required packages are available on CRAN.</p>
</div>
</div>
<div id="mirkat-microbiome-regression-based-kernel-association-test" class="section level2">
<h2>MiRKAT: Microbiome Regression-Based Kernel Association Test</h2>
<p>We begin by demonstrating the use of the Microbiome Regression-Based Kernel Association Test (MiRKAT) for binary and continuous traits.</p>
<div id="example-dataset" class="section level3">
<h3>Example Dataset</h3>
<p>We use the throat microbiome data (Charlson et al 2010) from the package GUniFrac to demonstrate our methods. Data are available for 60 subjects, of whom 28 were smokers and 32 were nonsmokers. Microbiome data were collected from right and left nasopharynx and oropharynx regions to form an OTU table with 856 OTUs. We want to evaluate whether smoking is associated with differences in microbiome composition in the upper respiratory tract, taking into consideration additional covariates including gender and antibiotic use within 3 months. We also use simulated data based on the throat dataset to demonstrate the usage of MiRKAT-S, MMiRKAT, MiRKAT.R, MiRKAT.Q, and KRV.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span>(<span class="st">&quot;throat.otu.tab&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">data</span>(<span class="st">&quot;throat.meta&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">data</span>(<span class="st">&quot;throat.tree&quot;</span>)</span></code></pre></div>
</div>
<div id="data-preparation" class="section level3">
<h3>Data Preparation</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>Male &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(throat.meta<span class="op">$</span>Sex <span class="op">==</span><span class="st"> &quot;Male&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a>Smoker &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(throat.meta<span class="op">$</span>SmokingStatus <span class="op">==</span><span class="st"> &quot;Smoker&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>anti &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(throat.meta<span class="op">$</span>AntibioticUsePast3Months_TimeFromAntibioticUsage <span class="op">!=</span><span class="st"> &quot;None&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>covar &lt;-<span class="st"> </span><span class="kw">cbind</span>(Male, anti)</span></code></pre></div>
</div>
<div id="create-the-unifrac-distances" class="section level3">
<h3>Create the UniFrac Distances</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Note: may want to rarefy the data to the minimum sequencing depth for unweighted (presence/absence) distances </span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">## otu.tab.rff &lt;- Rarefy(throat.otu.tab)$otu.tab.rff</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>unifracs &lt;-<span class="st"> </span><span class="kw">GUniFrac</span>(throat.otu.tab, throat.tree, <span class="dt">alpha =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>))<span class="op">$</span>unifracs</span>
<span id="cb3-4"><a href="#cb3-4"></a>D.weighted =<span class="st"> </span>unifracs[,,<span class="st">&quot;d_1&quot;</span>]</span>
<span id="cb3-5"><a href="#cb3-5"></a>D.unweighted =<span class="st"> </span>unifracs[,,<span class="st">&quot;d_UW&quot;</span>]</span>
<span id="cb3-6"><a href="#cb3-6"></a>D.generalized =<span class="st"> </span>unifracs[,,<span class="st">&quot;d_0.5&quot;</span>]</span>
<span id="cb3-7"><a href="#cb3-7"></a>D.BC =<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">vegdist</span>(throat.otu.tab, <span class="dt">method=</span><span class="st">&quot;bray&quot;</span>))</span></code></pre></div>
</div>
<div id="convert-distance-to-kernel-matrices" class="section level3">
<h3>Convert Distance to Kernel Matrices</h3>
<p>The D2K function in MiRKAT converts distance matrices to kernel matrices via the transformation <span class="math display">\[K = -\frac{1}{2} \left(I - \frac{1 1&#39;}{n}\right) D^2 \left(I - \frac{1 1&#39;}{n}\right)\]</span> Here, <span class="math inline">\(I\)</span> is the identity matrix and <span class="math inline">\(1\)</span> is an <span class="math inline">\(n\)</span>-vector of ones. To ensure that <span class="math inline">\(K\)</span> is positive semi-definite, we replace negative eigenvalues with zero. That is, we perform an eigenvalue decomposition <span class="math inline">\(K = U \Lambda U\)</span>, where <span class="math inline">\(\Lambda = \text{diag}(\lambda_1,...,\lambda_n)\)</span>, and then reconstruct the kernel matrix using the non-negative eigenvalues <span class="math inline">\(\Lambda^* = \text{diag}(\text{max}(\lambda_1,0),...,\text{max}(\lambda_n,0))\)</span> so that <span class="math inline">\(K = U \Lambda^* U\)</span>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>K.weighted =<span class="st"> </span><span class="kw">D2K</span>(D.weighted)</span>
<span id="cb4-2"><a href="#cb4-2"></a>K.unweighted =<span class="st"> </span><span class="kw">D2K</span>(D.unweighted)</span>
<span id="cb4-3"><a href="#cb4-3"></a>K.generalized =<span class="st"> </span><span class="kw">D2K</span>(D.generalized)</span>
<span id="cb4-4"><a href="#cb4-4"></a>K.BC =<span class="st"> </span><span class="kw">D2K</span>(D.BC)</span></code></pre></div>
</div>
<div id="testing-using-a-single-kernel" class="section level3">
<h3>Testing Using a Single Kernel</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">MiRKAT</span>(<span class="dt">y =</span> Smoker, <span class="dt">X =</span> covar, <span class="dt">Ks =</span> K.weighted, <span class="dt">out_type =</span> <span class="st">&quot;D&quot;</span>, </span>
<span id="cb5-2"><a href="#cb5-2"></a>       <span class="dt">method =</span> <span class="st">&quot;davies&quot;</span>, <span class="dt">returnKRV =</span> <span class="ot">TRUE</span>, <span class="dt">returnR2 =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## $indivP
## [1] 0.005306786
## 
## $KRV
## [1] 0.002884312
## 
## $R2
## [1] 0.01757917</code></pre>
<p>“Method” indicates which method the function should use to compute the <strong>kernel-specific p-value</strong>. “davies” represents an exact method that computes the p-value by inverting the characteristic function of the mixture chi-square distribution. We adopt an exact variance component test because most of the studies concerning microbiome compositions have modest sample size. “permutation” represents a residual permutation approach. “moment” represents an approximation method that matches the first two moments. When out_type=“C” (continuous outcome y), the “moment” method is the Satterthwaite approximation. When out_type = “D” (dichotomous outcome), the “moment” method is the small sample adjustment in Lee et al (2012). When sample size is modest (<span class="math inline">\(n&lt;100\)</span> for continuous or <span class="math inline">\(n&lt;200\)</span> for dichotomous outcome), the “moment” method can be inflated at very small size (such as <span class="math inline">\(\alpha\)</span> = 0.001), although the type I error at <span class="math inline">\(\alpha\)</span> = 0.05 is usually sustained. Therefore, we suggest using the Davies or permutation approaches for such situations.</p>
</div>
<div id="measures-of-effect-size" class="section level3">
<h3>Measures of Effect Size</h3>
<p>If returnKRV = TRUE and/or returnR2 = TRUE, the function also returns measures of effect size KRV and <span class="math inline">\(R^2\)</span> (respectively). The KRV statistic is as described in However, we caution that these measures of effect size remain very small (on the order of 1e-4 or smaller for the KRV statistic, and generally <span class="math inline">\(&lt;0.1\)</span> for R-squared) even when the majority of the variability in the outcome is explainable by the microbiome. Hence this should be used for internal comparisons rather than external discussions of, e.g., percent variability explained.</p>
</div>
<div id="properties-of-different-kernels" class="section level3">
<h3>Properties of Different Kernels</h3>
<p>How to choose an appropriate distance matrix and kernel for testing is a difficult question. However, it is important, since the distance matrix used to generate the kernel strongly affects the power of our tests. In particular, MiRKAT has highest power when the form of association between the microbiota and the outcome assumed by the kernel matches the true form of association. Poor choice of kernel will lead to reduced power, although the type I error will be preserved.</p>
<p>In the case of the UniFrac families and the Bray-Curtis dissimilarity, the factors at play are (1) the abundance of the associated taxa and (2) whether closely related taxa (phylogenetically) tend to be related or not related to the outcome as a group. For example, the following are some of the distance metrics that have been used for studies of the microbiome:</p>
<table>
<tbody>
<tr>
<td style="text-align:left;">
Distance
</td>
<td style="text-align:left;">
Phylogeny?
</td>
<td style="text-align:left;">
Abundance?
</td>
<td style="text-align:left;width: 20em; ">
Other notes
</td>
<td style="text-align:left;">
References
</td>
</tr>
<tr>
<td style="text-align:left;">
Unweighted UniFrac
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
No
</td>
<td style="text-align:left;width: 20em; ">
</td>
<td style="text-align:left;">
1
</td>
</tr>
<tr>
<td style="text-align:left;">
Weighted UniFrac
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;width: 20em; ">
</td>
<td style="text-align:left;">
2
</td>
</tr>
<tr>
<td style="text-align:left;">
Generalized UniFrac
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
(Yes)
</td>
<td style="text-align:left;width: 20em; ">
Parameter alpha defines extent to which abundance is taken into account
</td>
<td style="text-align:left;">
3
</td>
</tr>
<tr>
<td style="text-align:left;">
Jaccard
</td>
<td style="text-align:left;">
No
</td>
<td style="text-align:left;">
No
</td>
<td style="text-align:left;width: 20em; ">
1 - (taxa in both)/(taxa in either); typically presence/absence, but can be extended to an abundance-weighted version
</td>
<td style="text-align:left;">
4,5
</td>
</tr>
<tr>
<td style="text-align:left;">
Bray-Curtis
</td>
<td style="text-align:left;">
No
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;width: 20em; ">
Similar to Jaccard, but uses counts
</td>
<td style="text-align:left;">
6
</td>
</tr>
</tbody>
</table>
<p>In the table above, “Yes” indicates the distance or dissimilarity metric has the feature; “(Yes)” indicates that the feature is present either in some variations of the metric or is present to some extent; and “No” indicates that the feature is not present.</p>
<p>Depending on which of these characteristics are expected to be present in a particular study (based on prior knowledge or intuition), an appropriate distance or dissimilarity can be selected. If the study is exploratory and strong protection of type 1 error is not needed, several distance metrics can be explored. Depending on which one(s) are highly significant, some information can be gained about the nature of any association between the microbiota and the outcome.</p>
</div>
<div id="testing-using-multiple-kernels" class="section level3">
<h3>Testing Using Multiple Kernels</h3>
<p>We provide an omnibus test that takes into account multiple kernels simultaneously. The method is robust in the sense that it has substantial power gain compared to when an improper kernel is used, and has little power loss compared to when the best kernel is used.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>Ks =<span class="st"> </span><span class="kw">list</span>(<span class="dt">K.weighted =</span> K.weighted, <span class="dt">K.unweighted =</span> K.unweighted, <span class="dt">K.BC =</span> K.BC)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">MiRKAT</span>(<span class="dt">y =</span> Smoker, <span class="dt">Ks =</span> Ks, <span class="dt">X =</span> covar, <span class="dt">out_type =</span> <span class="st">&quot;D&quot;</span>, </span>
<span id="cb7-3"><a href="#cb7-3"></a>       <span class="dt">method =</span> <span class="st">&quot;davies&quot;</span>, <span class="dt">returnKRV =</span> <span class="ot">TRUE</span>, <span class="dt">returnR2 =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##  0.005306786  0.003801015  0.002287489 
## 
## $omnibus_p
## [1] 0.0075
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 0.0028843118 0.0010877663 0.0006235506 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##   0.01757917   0.01981955   0.02403491</code></pre>
</div>
<div id="testing-with-a-continuous-outcome-variable" class="section level3">
<h3>Testing with a Continuous Outcome Variable</h3>
<p>The only difference between using a continuous and dichotomous outcome variable is the value of the argument “out_type”, as shown below.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">nrow</span>(K.weighted))</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">MiRKAT</span>(<span class="dt">y =</span> y, <span class="dt">Ks =</span> Ks, <span class="dt">X =</span> covar, <span class="dt">out_type =</span> <span class="st">&quot;C&quot;</span>, <span class="dt">nperm =</span> <span class="dv">999</span>, </span>
<span id="cb9-3"><a href="#cb9-3"></a>       <span class="dt">method =</span> <span class="st">&quot;davies&quot;</span>, <span class="dt">returnKRV =</span> <span class="ot">TRUE</span>, <span class="dt">returnR2 =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## $indivP
## [1] 0.4401194 0.3623498 0.2494742
## 
## $omnibus_p
## [1] 0.401
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 0.0008987168 0.0006520430 0.0002601146 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##  0.001706709  0.007121559  0.004182427</code></pre>
<p>This function outputs p-values for association using each single kernel and an omnibus p-value considering all kernels. The omnibus p-value is obtained through residual permutation where the minimum p-values from each of the individual tests are used as test statistics. As before, the “method” option only indicates the method that is used for generating individual kernel p-values.</p>
</div>
</div>
<div id="mirkat-s-survival-outcome" class="section level2">
<h2>MiRKAT-S: Survival Outcome</h2>
<div id="simulate-time-to-event-data" class="section level3">
<h3>Simulate time to event data</h3>
<p>We again use Charlson’s throat microbiome data to demonstrate the use of MiRKAT-S. Data loading and preparation are the same as in the previous section. Because the original dataset has a binary phenotype (smoking) rather than a measure of censored time to event outcomes, we consider smoking status and gender as covariates and generate null outcome data from the Exponential distribution. Specifically, we generate survival times as <span class="math inline">\(S \sim \text{Exponential}(1 + I(\text{smoke}) + I(\text{male}))\)</span>, and censoring times as <span class="math inline">\(C \sim \text{Exponential}(0.75)\)</span>. Then the observed outcome measures are observation time <span class="math inline">\(T = \text{min}(S, C)\)</span> and an indicator variable for whether the event was observed, <span class="math inline">\(\Delta = I(S \leq C)\)</span>. That is, when delta = 1, the corresponding “obstime” is the survival time, and when delta = 0, the corresponding observation is censored and “obstime” is the time of censoring. This simulation procedure results in approximately 33% censoring.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Simulate outcomes</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"># Here, outcome is associated with covariates but unassociated with microbiota</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co"># Approximately 33% censoring</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>SurvTime &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">60</span>, (<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>Smoker <span class="op">+</span><span class="st"> </span>Male))</span>
<span id="cb11-5"><a href="#cb11-5"></a>CensTime &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">60</span>, <span class="fl">0.75</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a>Delta &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(SurvTime <span class="op">&lt;=</span><span class="st"> </span>CensTime )</span>
<span id="cb11-7"><a href="#cb11-7"></a>ObsTime &lt;-<span class="st"> </span><span class="kw">pmin</span>(SurvTime, CensTime)</span></code></pre></div>
<p>The p-value for the test may be generated using permutation or Davies’ exact method. Davies’ exact method, which computes the p-value based on a mixture of chi-square distributions, is used when “perm = F”. We use a small-sample correction to account for the modest sample sizes and sparse OTU count matrices that often result from studies of the microbiome.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># Davies&#39; exact method </span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">MiRKATS</span>(<span class="dt">obstime =</span> ObsTime, <span class="dt">delta =</span> Delta, <span class="dt">X =</span> <span class="kw">cbind</span>(Smoker, Male, anti), <span class="dt">Ks =</span> Ks, </span>
<span id="cb12-3"><a href="#cb12-3"></a>        <span class="dt">perm =</span> F, <span class="dt">returnKRV =</span> T, <span class="dt">returnR2 =</span> T)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##   0.07778749   0.47512860   0.08902296 
## 
## $omnibus_p
## [1] 0.1361361
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 0.0016499209 0.0008857490 0.0003264481 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##  0.005752281  0.013141469  0.006587602</code></pre>
<p>Using “perm = T” indicates that a permutation p-value should be calculated. Overall, permutation is recommended when the sample size is small, as Davies’ method may be slightly anti-conservative with very small sample sizes. MiRKAT-S will generate a warning when permutation is not used for sample sizes <span class="math inline">\(n \leq 50\)</span>. “nperm” indicates the number of permutations to perform to generate the p-value (default = 1000)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># Permutation </span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">MiRKATS</span>(<span class="dt">obstime =</span> ObsTime, <span class="dt">delta =</span> Delta, <span class="dt">X =</span> <span class="kw">cbind</span>(Smoker, Male, anti), <span class="dt">Ks =</span> Ks, </span>
<span id="cb14-3"><a href="#cb14-3"></a>        <span class="dt">perm =</span> T, <span class="dt">returnKRV =</span> T, <span class="dt">returnR2 =</span> T)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##   0.07707708   0.45145145   0.09409409 
## 
## $omnibus_p
## [1] 0.1341341
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 0.0016499209 0.0008857490 0.0003264481 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##  0.005752281  0.013141469  0.006587602</code></pre>
<p>The omnibus p-value is similar to that of MiRKAT, in which residual permutation is used to create a null distribution of p-values, and the minimum p-value from the original MiRKAT-S analysis is tested against this distribution as the test statistic of the omnibus test. The omnibus test is described further at <a href="https://github.com/hk1785/OMiSA" class="uri">https://github.com/hk1785/OMiSA</a> (Koh 2018, DOI: <a href="https://doi.org/10.1186/s12864-018-4599-8" class="uri">https://doi.org/10.1186/s12864-018-4599-8</a>).</p>
</div>
</div>
<div id="mmirkat-multivariate-continuous-outcome" class="section level2">
<h2>MMiRKAT: Multivariate Continuous Outcome</h2>
<p>MMiRKAT is designed to test the association between the microbiome and a low-dimensional multivariate continuous outcome. For structured or high dimensional outcomes, the kernel RV test (KRV) is recommended instead, as demonstrated in the next section.</p>
<p>We again use Charlson’s throat microbiome data to demonstrate the use of MMiRKAT. We generate multivariate outcomes <span class="math inline">\(Y \sim N_{3n}(0, I_{3n})\)</span>.</p>
<p>MMiRKAT uses a small-sample correction procedure for p-value calculation. There is no omnibus test in MMiRKAT; only kernel-specific p-values and, optionally, the KRV and R-squared statistics are returned.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a>n &lt;-<span class="st"> </span><span class="kw">nrow</span>(throat.otu.tab)</span>
<span id="cb16-3"><a href="#cb16-3"></a>Y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n<span class="op">*</span><span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>), n, <span class="dv">3</span>)</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">MMiRKAT</span>(<span class="dt">Y =</span> Y, <span class="dt">X =</span> <span class="kw">cbind</span>(Male, anti), <span class="dt">Ks =</span> Ks, </span>
<span id="cb16-5"><a href="#cb16-5"></a>        <span class="dt">returnKRV =</span> <span class="ot">TRUE</span>, <span class="dt">returnR2 =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##    0.1073553    0.2126433    0.2922759 
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 0.0012759596 0.0007062962 0.0002528821 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##   0.01036837   0.02518368   0.01191402</code></pre>
</div>
<div id="krv-high-dimensional-structured-outcome" class="section level2">
<h2>KRV: High-Dimensional Structured Outcome</h2>
<p>KRV (kernel RV coefficient) is designed to evaluate the association between microbiome composition and a structured, potentially high-dimensional phenotype, such as gene expression of a set of genes which are functionally related. The KRV statistic can capture nonlinear associations and complex relationships within the individual data types and between the complex multivariate phenotype and microbiome composition by measuring general dependency.</p>
<p>Two kernels are involved in KRV statistics: one kernel for microbiome composition, which can be obtained by transforming the distance metrics as in the previous sections, and one kernel capturing similarities in the phenotypes. As an alternative, KRV can also take as input a kernel matrix for microbiome composition, a multivariate phenotype y, and a set of additional covariates X. In this case, a multivariate regression is carried out, and then the residuals of this regression are subsequently used to construct a Gaussian or linear kernel matrix.</p>
<div id="create-the-kernel-matrix-of-simulated-data" class="section level3">
<h3>Create the Kernel Matrix of Simulated Data</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>rho =<span class="st"> </span><span class="fl">0.2</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>Va =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(rho, (<span class="dv">2</span><span class="op">*</span>n)<span class="op">^</span><span class="dv">2</span>), <span class="dv">2</span><span class="op">*</span>n, <span class="dv">2</span><span class="op">*</span>n)<span class="op">+</span><span class="kw">diag</span>(<span class="dv">1</span><span class="op">-</span>rho, <span class="dv">2</span><span class="op">*</span>n)</span>
<span id="cb18-4"><a href="#cb18-4"></a>G =<span class="st"> </span><span class="kw">mvrnorm</span>(n, <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>n), Va)</span></code></pre></div>
</div>
<div id="testing-using-an-outcome-kernel-matrix" class="section level3">
<h3>Testing Using an Outcome Kernel Matrix</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>lin.K.y =<span class="st"> </span>G <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(G)</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">KRV</span>(<span class="dt">kernels.otu =</span> Ks, <span class="dt">kernel.y =</span> lin.K.y, </span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">returnKRV =</span> <span class="ot">TRUE</span>, <span class="dt">returnR2 =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##    0.6231597    0.4956971    0.6321714 
## 
## $omnibus_p
## [1] 0.6134599
## 
## $KRV
##   K.weighted K.unweighted         K.BC 
## 1.713514e-04 1.226831e-04 4.210276e-05 
## 
## $R2
##   K.weighted K.unweighted         K.BC 
##   0.03958771   0.16086562   0.06991840</code></pre>
</div>
<div id="testing-with-multiple-kernels-using-the-covariate-option" class="section level3">
<h3>Testing with Multiple Kernels, Using the Covariate Option</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">KRV</span>(<span class="dt">y =</span> G, <span class="dt">X =</span> <span class="kw">cbind</span>(Male, anti), <span class="dt">kernels.otu =</span> Ks, <span class="dt">kernel.y =</span> <span class="st">&quot;linear&quot;</span>)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##    0.6228336    0.5955235    0.6499288 
## 
## $omnibus_p
## [1] 0.6423704
## 
## $KRV
## NULL
## 
## $R2
## NULL</code></pre>
<p>An omnibus test has also been implemented for the KRV function. This omnibus test is different from the other omnibus tests in the package, as it creates an “omnibus kernel matrix” and then performs the KRV analysis on that omnibus kernel. The omnibus kernel matrix is constructed via the second formulation in Zhan et al (2017), an unsupervised weighted combination of kernels that the authors found to have the best performance across a range of simulation settings. Specifically, the omnibus kernel is defined as <span class="math display">\[K_{om} = \sum_{i=1}^m \frac{K_i}{tr(K_i)}.\]</span> The p-value from this single omnibus kernel is returned as the omnibus p-value for KRV.</p>
</div>
</div>
<div id="robust-mirkat" class="section level2">
<h2>Robust MiRKAT</h2>
<p>MiRKAT is sensitive to strong skewness or outliers in continuous outcome variables, but many biological features have non-Gaussian distributions. To accommodate such features, rather than using OLS, robust MiRKAT uses a robust regression method. Specifically, a kernel matrix for the outcome is created using a linear kernel based on the residuals from robust linear regression (MiRKAT-R) or quantile regression (MiRKAT-Q) of the outcome on non-microbiome covariates, then related to the microbiome kernel using the KRV test. Note that if there are no additional covariates, MiRKAT-R and MiRKAT-Q simplify to MiRKAT.</p>
<p>We additionally note that quantile regression has lower power than robust regression in every scenario considered, and hence recommend use of MiRKAT-R in most circumstances. Both functions call the KRV function once an outcome kernel matrix has been created using quantile or robust regression, so the omnibus tests for MiRKAT.Q and MiRKAT.R are the same as for KRV.</p>
<div id="mirkat.r-continuous-outcomes-with-robust-linear-regression" class="section level3">
<h3>MiRKAT.R: Continuous Outcomes with Robust Linear Regression</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>y &lt;-<span class="st"> </span><span class="kw">rchisq</span>(<span class="kw">nrow</span>(K.weighted), <span class="dv">1</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">MiRKAT.R</span>(<span class="dt">y =</span> y, <span class="dt">X =</span> <span class="kw">cbind</span>(Male, anti), <span class="dt">Ks =</span> Ks)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##    0.5502230    0.9116325    0.3288858 
## 
## $omnibus_p
## [1] 0.5506275
## 
## $KRV
## NULL
## 
## $R2
## NULL</code></pre>
</div>
<div id="mirkat.q-continuous-outcomes-with-quantile-regression" class="section level3">
<h3>MiRKAT.Q: Continuous Outcomes with Quantile Regression</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">MiRKAT.Q</span>(<span class="dt">y =</span> y, <span class="dt">X=</span> <span class="kw">cbind</span>(Male, anti), <span class="dt">Ks =</span> Ks)</span></code></pre></div>
<pre><code>## $p_values
##   K.weighted K.unweighted         K.BC 
##    0.6362740    0.4675527    0.6828106 
## 
## $omnibus_p
## [1] 0.6336712
## 
## $KRV
## NULL
## 
## $R2
## NULL</code></pre>
</div>
</div>
<div id="cskat-longitudinalcorrelated-data-continuous-outcomes" class="section level2">
<h2>CSKAT: Longitudinal/Correlated Data, Continuous Outcomes</h2>
<p>CSKAT is designed to allow for microbiome association testing using longitudinal or otherwise correlated data. It is sometimes useful to look for micriobiome association not from single measurements of many people, but rather from measuring only a select few people multiple times across a longer time period. This case-study-like approach allows researchers to do things like track the effectiveness of a certain drug on a group of patients. It also allows researchers to do microbiome association testing on family members, so as to lessen the confounding effects of DNA. In both scenarios, the assumption of independence that all the above functions require is not met. CSKAT allows for microbiome association testing despite this dependence.</p>
<p>We switch to a different simulation approach for these last two functions, as they both deal with correlated data.</p>
<div id="prepare-the-data" class="section level3">
<h3>Prepare the Data</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># Import example microbiome data with Gaussian traits</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">data</span>(nordata)</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co"># Extract microbiome and meta information</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>otu.tab &lt;-<span class="st"> </span>nordata<span class="op">$</span>nor.otu.tab</span>
<span id="cb27-6"><a href="#cb27-6"></a>tree &lt;-<span class="st"> </span>nordata<span class="op">$</span>nor.tree</span>
<span id="cb27-7"><a href="#cb27-7"></a>meta &lt;-<span class="st"> </span>nordata<span class="op">$</span>nor.meta</span></code></pre></div>
</div>
<div id="create-the-unifrac-distances-1" class="section level3">
<h3>Create the UniFrac Distances</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>Ds &lt;-<span class="st"> </span><span class="kw">GUniFrac</span>(otu.tab, tree, <span class="dt">alpha=</span><span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>))<span class="op">$</span>unifracs</span>
<span id="cb28-2"><a href="#cb28-2"></a> </span>
<span id="cb28-3"><a href="#cb28-3"></a>D.unweighted &lt;-<span class="st"> </span>Ds[,,<span class="st">&quot;d_UW&quot;</span>]</span>
<span id="cb28-4"><a href="#cb28-4"></a>D.generalized &lt;-<span class="st"> </span>Ds[,,<span class="st">&quot;d_0.5&quot;</span>]</span>
<span id="cb28-5"><a href="#cb28-5"></a>D.weighted &lt;-<span class="st"> </span>Ds[,,<span class="st">&quot;d_1&quot;</span>]</span></code></pre></div>
</div>
<div id="convert-distance-to-kernel-matrices-1" class="section level3">
<h3>Convert Distance to Kernel Matrices</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>K.unweighted &lt;-<span class="st"> </span><span class="kw">D2K</span>(D.unweighted)</span>
<span id="cb29-2"><a href="#cb29-2"></a>K.generalized &lt;-<span class="st"> </span><span class="kw">D2K</span>(D.generalized)</span>
<span id="cb29-3"><a href="#cb29-3"></a>K.weighted &lt;-<span class="st"> </span><span class="kw">D2K</span>(D.weighted)</span>
<span id="cb29-4"><a href="#cb29-4"></a>Ks &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">K.weighted =</span> K.weighted, </span>
<span id="cb29-5"><a href="#cb29-5"></a>           <span class="dt">K.unweighted =</span> K.unweighted, </span>
<span id="cb29-6"><a href="#cb29-6"></a>           <span class="dt">K.generalized =</span> K.generalized)</span></code></pre></div>
</div>
<div id="testing-using-multiple-kernels-1" class="section level3">
<h3>Testing Using Multiple Kernels</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">CSKAT</span>(<span class="dt">formula.H0 =</span> y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2 <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>id), <span class="dt">data =</span> meta, <span class="dt">Ks =</span> Ks)</span></code></pre></div>
<pre><code>## $p_values
##    K.weighted  K.unweighted K.generalized 
##   0.000158162   0.501216086   0.023604631 
## 
## $omnibus_p
## [1] 0.001</code></pre>
</div>
</div>
<div id="glmm-mirkat-longitudinalcorrelated-continuous-binary-or-count-data-generalized-linear-mixed-model" class="section level2">
<h2>GLMM-MiRKAT: Longitudinal/Correlated Continuous, Binary, or Count Data (Generalized Linear Mixed Model)</h2>
<p>While CSKAT allows for miciobiome association testing with Gaussian traits (such as body mass index), GLMMMiRKAT allows for Guassian, binomial (e.g. disease status, treatment/placebo) and Poisson (e.g. number of tumors/treatments) traits, making it a much more versatile function overall when it comes to correlated data.</p>
<p>GLMM-MiRKAT uses a permuation approach for its p-value and omnibus p-value calculations. Because of this, however, it is not as computationally efficient as CSKAT when it comes to Gaussian traits, especially with larger samples. This is because CSKAT uses a computational approach rather than a permuation one, using the Davies function for its p-value calculation. CSKAT is called by GLMM-MiRKAT when GLMM-MiRKAT is given a Gaussian trait and method = “davies”.</p>
<div id="example-1.-gaussian-traits-e.g.-body-mass-index" class="section level3">
<h3>Example 1. Gaussian traits (e.g., body mass index)</h3>
<p>GLMM-MiRKAT returns kernel-specific and omnibus p-values. No measures of effect size are available for GLMM-MiRKAT.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># GLMM-MiRKAT with permutation test</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">GLMMMiRKAT</span>(<span class="dt">y =</span> meta<span class="op">$</span>y, <span class="dt">X =</span> <span class="kw">cbind</span>(meta<span class="op">$</span>x1, meta<span class="op">$</span>x2), <span class="dt">id =</span> meta<span class="op">$</span>id, <span class="dt">Ks =</span> Ks, <span class="dt">model =</span> <span class="st">&quot;gaussian&quot;</span>)</span></code></pre></div>
<pre><code>## $p_values
##    K.weighted  K.unweighted K.generalized 
##    0.00099980    0.53029394    0.07318536 
## 
## $omnibus_p
## [1] 0.00179964</code></pre>
<p>With options model = “gaussian” and method = “davies”, GLMM-MiRKAT is equivalent to CSKAT (as described above).</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># GLMM-MiRKAT with Davies p-value (equivalent to CSKAT) </span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">GLMMMiRKAT</span>(<span class="dt">y =</span> meta<span class="op">$</span>y, <span class="dt">X =</span> <span class="kw">cbind</span>(meta<span class="op">$</span>x1, meta<span class="op">$</span>x2), <span class="dt">Ks =</span> Ks, </span>
<span id="cb34-3"><a href="#cb34-3"></a>           <span class="dt">id =</span> meta<span class="op">$</span>id, <span class="dt">model =</span> <span class="st">&quot;gaussian&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;davies&quot;</span>, </span>
<span id="cb34-4"><a href="#cb34-4"></a>           <span class="dt">formula.H0 =</span> y <span class="op">~</span><span class="st"> </span><span class="kw">cbind</span>(meta<span class="op">$</span>x1, meta<span class="op">$</span>x2) <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>meta<span class="op">$</span>id), </span>
<span id="cb34-5"><a href="#cb34-5"></a>           <span class="dt">slope =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## $p_values
##    K.weighted  K.unweighted K.generalized 
##   0.000158162   0.501216086   0.023604631 
## 
## $omnibus_p
## [1] 0.00019996</code></pre>
</div>
<div id="example-2.-binomial-traits-e.g.-disease-status-treatmentplacebo" class="section level3">
<h3>Example 2. Binomial traits (e.g., disease status, treatment/placebo)</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a> <span class="co"># Import microbiome data with binomial traits</span></span>
<span id="cb36-2"><a href="#cb36-2"></a> <span class="kw">data</span>(bindata)</span>
<span id="cb36-3"><a href="#cb36-3"></a></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="co"># Extract microbiome and meta information</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="co"># (Microbiome is the same as for Gaussian outcomes)</span></span>
<span id="cb36-6"><a href="#cb36-6"></a>otu.tab &lt;-<span class="st"> </span>bindata<span class="op">$</span>bin.otu.tab</span>
<span id="cb36-7"><a href="#cb36-7"></a>tree &lt;-<span class="st"> </span>bindata<span class="op">$</span>bin.tree</span>
<span id="cb36-8"><a href="#cb36-8"></a>meta &lt;-<span class="st"> </span>bindata<span class="op">$</span>bin.meta</span>
<span id="cb36-9"><a href="#cb36-9"></a> </span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="co"># Run GLMM-MiRKAT</span></span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="kw">GLMMMiRKAT</span>(meta<span class="op">$</span>y, <span class="dt">X =</span> <span class="kw">cbind</span>(meta<span class="op">$</span>x1, meta<span class="op">$</span>x2), <span class="dt">id =</span> meta<span class="op">$</span>id, </span>
<span id="cb36-12"><a href="#cb36-12"></a>           <span class="dt">Ks =</span> Ks, <span class="dt">model =</span> <span class="st">&quot;binomial&quot;</span>)</span></code></pre></div>
<pre><code>## $p_values
##    K.weighted  K.unweighted K.generalized 
##     0.9162168     0.6376725     0.8384323 
## 
## $omnibus_p
## [1] 0.8130374</code></pre>
</div>
<div id="example-3.-poisson-traits-e.g.-number-of-tumors" class="section level3">
<h3>Example 3. Poisson traits (e.g., number of tumors)</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="co"># Import microbiome data with Poisson traits</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">data</span>(poisdata)</span>
<span id="cb38-3"><a href="#cb38-3"></a></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="co"># Extract microbiome and meta information</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="co"># (Microbiome is again the same)</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>otu.tab &lt;-<span class="st"> </span>poisdata<span class="op">$</span>pois.otu.tab</span>
<span id="cb38-7"><a href="#cb38-7"></a>tree &lt;-<span class="st"> </span>poisdata<span class="op">$</span>pois.tree</span>
<span id="cb38-8"><a href="#cb38-8"></a>meta &lt;-<span class="st"> </span>poisdata<span class="op">$</span>pois.meta</span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a><span class="co"># Run GLMM-MiRKAT</span></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="kw">GLMMMiRKAT</span>(meta<span class="op">$</span>y, <span class="dt">X =</span> <span class="kw">cbind</span>(meta<span class="op">$</span>x1, meta<span class="op">$</span>x2), <span class="dt">id =</span> meta<span class="op">$</span>id, </span>
<span id="cb38-12"><a href="#cb38-12"></a>           <span class="dt">Ks =</span> Ks, <span class="dt">model =</span> <span class="st">&quot;poisson&quot;</span>)</span></code></pre></div>
<pre><code>## $p_values
##    K.weighted  K.unweighted K.generalized 
##     0.1425715     0.1737652     0.2523495 
## 
## $omnibus_p
## [1] 0.2789442</code></pre>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
